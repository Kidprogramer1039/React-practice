# React_study

목표
---
1. 모르는 리액트 개념 탐색 능력 증진
2. 배운 내용들을 바탕으로 리액트 사이트 구축.
3. 리액트 개발 능력 향상을 통한 VideoJudicate 성공적인 프로젝트 완성

## 2.20까지 연습한 프로젝트는 저작권 문제로 private로 업로드 해둬서 깃 허브에는 안 보임.

# 배운 내용 정리

## 리액트란?
- 사용자 인터페이스 구축을 위한 자바스크립트 라이브러리
- 전환이 부드럽고, 즉각적인 것이 장점
- 모바일 앱과 비슷하다고 보면 됨
- 자바스크립트를 이용해 리액트는 사용자 인터페이스를 재로딩 없이 로딩
- html 코드와 자바스크립트의 코드를 섞어 쓰기 떄문에, 코드를 보기에도 편하다.
- 명령형이 아닌 선언형임. 리액트가 명령한 과정의 단계를 알아서 처리하고 수행해주기 때문. 그렇기에 코드도 더욱 간결하다.

## 자잘한 팁
1. 컴포넌트를 감쌀 떄는, Fragment를 사용하거나, 빈 컴포넌트<>를 사용해도 된다.
2. useState를 사용하여 변수의 상태관리를 용이하게 할 수 있다.

- 리액트의 핵심 : 상태 수는 최소화 하고, 거기서 최대한 많은 값을 파생시키는 것

# 디버깅에 관하여
- 에러 메시지가 발생하면, 줄을 따라가면서 최종적으로 어디에 문제가 발생했는지 찾아보는게 답이다. 
- breakPoint를 사용하여 에러를 찾는 것도 방법
- React의 StrictMode 컴포넌트를 사용하면 앱을 2번 실행시켜줌 -> 에러 확인에 용이


## 리액트 기능, 개념 정리
---
### React Fragment 개념
- 리액트는 값을 가질 때, 하나의 번들로 이루어진 태그를 리턴해야 한다.
- 그래서 컴포넌트를 반환할 때 <>로 감싸거나 <Fragment>를 써서 반환해줘야 함.

### useState
```
1. useState 안에 {}를 넣어서 여러 변수의 변화 정보를 한번에 관리할 수 있다.
2. 문자열과 숫자를 더할 경우, 앞쪽에 있는 형식을 따라가기 때문에 미리 초기화를 잘 시켜둬야 한다.
```
### Ref
```
- 값을 불러올 때, 간결한 코드로 값을 불러오는 것이 가능함
- 접근은 가능, 그러나 실시간 변경은 못 해서 state랑 같이 쓰는 경우가 많음
- UI에 영향을 주지 않고 값만 업데이트 하고 싶을 때 종종 사용
- 재실행 될 때 참조가 변수처럼 초기화 되거나 삭제되지 않는다는 것이 장점.
```
### forwardRef
```
- ref은 props가 아니기 때문에, 전달해줄때 forwardRef를 사용해서 전달해줘야 함.
- 컴포넌트를 다른 컴포넌트로 전달하는 데 용이
```
### useImperativeHandle
```
- dialog가 변경 되는 등 JSX코드가 변경되어도 유동적으로 컴포넌트 전달을 용이하게 해주는 함수
- 이렇게 되면 참조하는 함수에서 showModal을 사용하지 않고, open만 써도 showModal이 내부에서 개별 실행되게 할 수 있음.
```
### portal
```
- 이걸 사용하면 html element 안에서 body 태그 내부의 최상단에 원하는 다이얼로그를 땡겨올 수 있다.
- react-dom에서 끌어오는 함수는 리액트와 dom이 상호작용하는 느낌이라고 보면 됨.
(리액트 라이브러리가 아니라, React Dom 라이브러리에서 끌어온다고 함.)
- createportal을 사용하려면 결국 직접적으로 index.html을 건드려야 한다.

- 얻을 수 있는 이점 : 혹시 모를 형식 문제 방지 가능, 코드 정리 가능
```

### prop Drilling
```
- 넘겨주고자 하는 prop을 수많은 컴포넌트를 거쳐서 전달해주는 형식.
- 여기서 거쳐가는 컴포넌트들이 그 prop을 사용하지 않는다면, 코드의 효율성 저하를 야기함.

해결책
1. 컴포넌트 합성을 통해 리팩토링
- 컴포넌트의 children 부분에 drilling의 원인이 되는 코드를 집어넣어서, 그 컴포넌트에서 한번에 해결하는거임.
- drilling은 해결할 수 있지만, App 컴포넌트에 모든 컴포넌트 코드가 몰빵되서 보기 안 좋다는 단점이 있음.

2. context API 사용
- context에 state들을 연결시켜서, 모든 컴포넌트에 영향을 미치는 state를 만드는거임. 그리고 그 state를 끌어오는 느낌.
- createContext를 이용해 만들고, useContext, provider를 이용해 사용.
- consumer를 사용할 수도 있으나, 코드의 가독성 문제가 있기 때문에 그냥 provider만 쓰는게 좋음
- context 값에 접근할 경우, 컴포넌트 함수가 재실행됨(새로운 UI 생성 목적).
```

### context API로 인한 APP 컴포넌트 과부하 대처
```
- APP 컴포넌트에서 설정하지 말고, context가 지정된 컴포넌트에서 정리하자.(context outsourcing)
```
### useReducer
```
- 여러 복잡한 값을 단순한 값으로 치환해주는 함수
- 상태값을 useReducer를 이용하여 수정해 줄 수도 있음
```
### Side Effect, useEffect
- 컴포넌트 렌더링엔 영향을 미치지 않지만, 실행시키기 위해 필요한 과정
- 다시 말해, 컴포넌트의 주목적과는 연관 없는데 또 부수 효과로써는 필요한 작업들이라 애매한 것들을 쉽게 처리하기 위해 필요한 함수라는 뜻.

- useEffect는 jsx코드가 전부 반한되고 실행된다.
└ 이 기술은 dialog의 close나, showModal을 사용할 때 충돌이 발생하지 않도록 하기 위해 사용이 가능하다.

- 그리고 useEffect는 의존성 배열을 가지게 할 수 있는데, 이 배열을 쓰게 될 경우 배열값이 변해야 내부 함수가 실행되는 특징을 지니고 있다.
- 다른 것들도 마찬가지지만, 과한 사용은 금물

## useCallBack
- 컴포넌트가 실행될 때마다 재생성되지 않도록 만들어주는 함수.
- 이 함수 안에 들어가 있는 함수는 메모리로 저장됨.
- useEffect와 같은 점이라고 하면, 종속성 함수가 변경될 경우 값이 바뀐다는 점? (함수가 비어있으면 재실행 되지 않음)

# key props 목적
- 인스턴스 초기화의 목적도 있음
- key를 중복 사용해야 하는 경우 해결법 : 상위 컴포넌트에서 key를 정의해주면 된다.